#!/usr/bin/env python

import math

import libgreader
import cairo
import gtk
import gobject
import rsvg
import Image

def convert_format(data, width, height, in_format, out_format):
	# PIL uses big-endian as well
	img = Image.frombuffer(
		out_format,
		(width, height),
		data,
		'raw',
		in_format,
		0,
		1
	)

	return img.tostring('raw', out_format, 0, 1)


def pixbuf_from_surface(surface):
	# GDKs format: RGBA or RGB, big endian byte order
	# cairos format: ARGB or XRGB, little endian byte order
	#             => BGRA or BGRX
	#                             (at least on x86/AMD64)
	if cairo.FORMAT_ARGB32 == surface.get_format():
		in_format = 'BGRA'
		out_format = 'RGBA'
		alpha = True
		stride = surface.get_width()*4
	elif cairo.FORMAT_RGB24 == surface.get_format():
		in_format = 'BGRX'
		out_format = 'RGB'
		alpha = False
		stride = surface.get_width()*3
	else: raise Exception('Can only handle RGB or RGBA formats.')

	data = convert_format(
		surface.get_data(),
		surface.get_width(),
		surface.get_height(),
		in_format,
		out_format
	)

	pixbuf = gtk.gdk.pixbuf_new_from_data(
		data = data,
		colorspace = gtk.gdk.COLORSPACE_RGB,
		has_alpha = alpha,
		bits_per_sample = 8,
		width = surface.get_width(),
		height = surface.get_height(),
		rowstride = stride
	)

	return pixbuf


class FeedIcon(gtk.StatusIcon):
	def  __init__(self, background_file, *args, **kwargs):
		super(FeedIcon, self).__init__(*args, **kwargs)
		self.unread_count = 0
		self.connect('size-changed', self.on_size_changed, None)

		# load background
		with file(background_file) as f:
			self.icon_code = f.read()

	def on_size_changed(self, status_icon, size, statusicon):
		self.size = size

		# create new pixbuf with correct size
		self.redraw()

	def redraw(self):
		# create new cairo surface
		surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, self.size, self.size)

		# context scaled to 1.0/1.0
		cr = cairo.Context(surface)
		cr.scale(self.size, self.size)

		# adjust icon
		icon_str = ""
		if self.unread_count:
			if self.unread_count > 99:
				icon_str = '99+'
			else:
				icon_str = str(self.unread_count)
		new_icon_code = self.icon_code % {'rss_number': icon_str}
		svg_handle = rsvg.Handle(data = new_icon_code)

		# render background
		cr.save()
		cr.scale(1./svg_handle.get_property('width'), 1./svg_handle.get_property('height'))
		svg_handle.render_cairo(cr)
		cr.restore()

		# fetch
		pixbuf = pixbuf_from_surface(surface)

		# set icon from pixbuf
		self.set_from_pixbuf(pixbuf)


class GoogleReaderIcon(FeedIcon):
	icon_file = 'icon.svg'
	def __init__(self, glade_file, username, password):
		super(GoogleReaderIcon, self).__init__(self.icon_file)
		auth = libgreader.ClientAuth(username, password)
		self.reader = libgreader.GoogleReader(auth)
		self.timeout_source = None
		builder = gtk.Builder()
		builder.add_from_file(glade_file)

		self.menu = builder.get_object('tray_menu')
		self.preferences_dialog = builder.get_object('preferences_dialog')

		self.connect('popup-menu', self.on_popup_menu)

		preferences_action = builder.get_object('a_open_preferences')
		preferences_action.connect('activate', self.on_open_preferences)

	def on_popup_menu(self, status_icon, button, activate_time):
		self.menu.popup(None, None, None, button, activate_time)

	def on_open_preferences(self, *args):

		if self.preferences_dialog.run():
			# save new data
			pass
		self.preferences_dialog.hide()

	@property
	def unread_count(self):
		self.update()
		return self._unread_count

	@unread_count.setter
	def unread_count(self, val):
		self._unread_count = val

	def update(self):
		self.reader.buildSubscriptionList()
		self._unread_count = sum( feed.unread for feed in self.reader.feeds if feed.unread )

	def set_update_interval(self, seconds):
		def call_update():
			self.redraw()
			return True

		if self.timeout_source: gobject.source_remove(self.timeout_source)

		self.timeout_source = gobject.timeout_add(seconds * 1000, call_update) # every 5 minutes


if '__main__' == __name__:
	# load data from config file (FIXME: use GUI,
	# gconf and gnome keyring)
	import os
	import yaml

	glade_file = 'google-reader-notification.glade'
	gobject.set_application_name('google-reader-notification')

	with file(os.path.expanduser('~/.google-reader-notification')) as f:
		config = yaml.safe_load(f)

	icon = GoogleReaderIcon(glade_file, config['username'], config['password'])
	icon.set_update_interval(5*60)

	gtk.main()
